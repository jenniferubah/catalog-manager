// Package cluster provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.1 DO NOT EDIT.
package cluster

import (
	"encoding/json"
	"fmt"

	externalRef0 "github.com/dcm-project/catalog-manager/api/v1alpha1/servicetypes"
)

// Defines values for ControlPlaneNodesCount.
const (
	N1 ControlPlaneNodesCount = 1
	N3 ControlPlaneNodesCount = 3
	N5 ControlPlaneNodesCount = 5
)

// ClusterSpec defines model for ClusterSpec.
type ClusterSpec struct {
	// Metadata Resource metadata for identification and governance.
	// Used by all service type specifications.
	Metadata externalRef0.ServiceMetadata `json:"metadata"`

	// Nodes Node configuration
	Nodes Nodes `json:"nodes"`

	// ProviderHints Optional provider-specific configuration.
	//
	// Allows platform-specific settings without breaking portability.
	// Providers use hints they recognize and ignore unknown hints.
	//
	// Keys are provider identifiers (e.g., kubevirt, vmware, aws).
	// Values are provider-specific configuration objects.
	ProviderHints *externalRef0.ProviderHints `json:"providerHints,omitempty"`

	// ServiceType Service type identifier.
	// Makes the payload self-describing and enables routing/validation.
	ServiceType externalRef0.ServiceType `json:"serviceType"`

	// Version Kubernetes version (e.g., "1.29", "1.30", "1.31").
	//
	// Use standard Kubernetes version numbers. Providers translate
	// to their distribution's version if needed (e.g., OpenShift
	// providers map K8s 1.27 to OCP 4.14).
	Version              string                 `json:"version"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// ControlPlaneNodes Control plane nodes configuration.
// Managed services (ACM (with Hypershift),EKS, GKE, AKS) may ignore these fields.
type ControlPlaneNodes struct {
	// Count Number of control plane nodes (1, 3, or 5)
	Count ControlPlaneNodesCount `json:"count"`

	// Cpu CPU cores per control plane node
	Cpu int `json:"cpu"`

	// Memory Memory per control plane node with unit suffix
	Memory string `json:"memory"`

	// Storage Storage per control plane node with unit suffix
	Storage              string                 `json:"storage"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// ControlPlaneNodesCount Number of control plane nodes (1, 3, or 5)
type ControlPlaneNodesCount int

// Nodes Node configuration
type Nodes struct {
	// ControlPlane Control plane nodes configuration.
	// Managed services (ACM (with Hypershift),EKS, GKE, AKS) may ignore these fields.
	ControlPlane ControlPlaneNodes `json:"controlPlane"`

	// Worker Worker nodes configuration
	Worker               WorkerNodes            `json:"worker"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// WorkerNodes Worker nodes configuration
type WorkerNodes struct {
	// Count Number of worker nodes
	Count int `json:"count"`

	// Cpu CPU cores per worker node
	Cpu int `json:"cpu"`

	// Memory Memory per worker node with unit suffix
	Memory string `json:"memory"`

	// Storage Storage per worker node with unit suffix
	Storage              string                 `json:"storage"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// Getter for additional properties for ClusterSpec. Returns the specified
// element and whether it was found
func (a ClusterSpec) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for ClusterSpec
func (a *ClusterSpec) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for ClusterSpec to handle AdditionalProperties
func (a *ClusterSpec) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["metadata"]; found {
		err = json.Unmarshal(raw, &a.Metadata)
		if err != nil {
			return fmt.Errorf("error reading 'metadata': %w", err)
		}
		delete(object, "metadata")
	}

	if raw, found := object["nodes"]; found {
		err = json.Unmarshal(raw, &a.Nodes)
		if err != nil {
			return fmt.Errorf("error reading 'nodes': %w", err)
		}
		delete(object, "nodes")
	}

	if raw, found := object["providerHints"]; found {
		err = json.Unmarshal(raw, &a.ProviderHints)
		if err != nil {
			return fmt.Errorf("error reading 'providerHints': %w", err)
		}
		delete(object, "providerHints")
	}

	if raw, found := object["serviceType"]; found {
		err = json.Unmarshal(raw, &a.ServiceType)
		if err != nil {
			return fmt.Errorf("error reading 'serviceType': %w", err)
		}
		delete(object, "serviceType")
	}

	if raw, found := object["version"]; found {
		err = json.Unmarshal(raw, &a.Version)
		if err != nil {
			return fmt.Errorf("error reading 'version': %w", err)
		}
		delete(object, "version")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for ClusterSpec to handle AdditionalProperties
func (a ClusterSpec) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	object["metadata"], err = json.Marshal(a.Metadata)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'metadata': %w", err)
	}

	object["nodes"], err = json.Marshal(a.Nodes)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'nodes': %w", err)
	}

	if a.ProviderHints != nil {
		object["providerHints"], err = json.Marshal(a.ProviderHints)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'providerHints': %w", err)
		}
	}

	object["serviceType"], err = json.Marshal(a.ServiceType)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'serviceType': %w", err)
	}

	object["version"], err = json.Marshal(a.Version)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'version': %w", err)
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for ControlPlaneNodes. Returns the specified
// element and whether it was found
func (a ControlPlaneNodes) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for ControlPlaneNodes
func (a *ControlPlaneNodes) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for ControlPlaneNodes to handle AdditionalProperties
func (a *ControlPlaneNodes) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["count"]; found {
		err = json.Unmarshal(raw, &a.Count)
		if err != nil {
			return fmt.Errorf("error reading 'count': %w", err)
		}
		delete(object, "count")
	}

	if raw, found := object["cpu"]; found {
		err = json.Unmarshal(raw, &a.Cpu)
		if err != nil {
			return fmt.Errorf("error reading 'cpu': %w", err)
		}
		delete(object, "cpu")
	}

	if raw, found := object["memory"]; found {
		err = json.Unmarshal(raw, &a.Memory)
		if err != nil {
			return fmt.Errorf("error reading 'memory': %w", err)
		}
		delete(object, "memory")
	}

	if raw, found := object["storage"]; found {
		err = json.Unmarshal(raw, &a.Storage)
		if err != nil {
			return fmt.Errorf("error reading 'storage': %w", err)
		}
		delete(object, "storage")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for ControlPlaneNodes to handle AdditionalProperties
func (a ControlPlaneNodes) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	object["count"], err = json.Marshal(a.Count)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'count': %w", err)
	}

	object["cpu"], err = json.Marshal(a.Cpu)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'cpu': %w", err)
	}

	object["memory"], err = json.Marshal(a.Memory)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'memory': %w", err)
	}

	object["storage"], err = json.Marshal(a.Storage)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'storage': %w", err)
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for Nodes. Returns the specified
// element and whether it was found
func (a Nodes) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for Nodes
func (a *Nodes) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for Nodes to handle AdditionalProperties
func (a *Nodes) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["controlPlane"]; found {
		err = json.Unmarshal(raw, &a.ControlPlane)
		if err != nil {
			return fmt.Errorf("error reading 'controlPlane': %w", err)
		}
		delete(object, "controlPlane")
	}

	if raw, found := object["worker"]; found {
		err = json.Unmarshal(raw, &a.Worker)
		if err != nil {
			return fmt.Errorf("error reading 'worker': %w", err)
		}
		delete(object, "worker")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for Nodes to handle AdditionalProperties
func (a Nodes) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	object["controlPlane"], err = json.Marshal(a.ControlPlane)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'controlPlane': %w", err)
	}

	object["worker"], err = json.Marshal(a.Worker)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'worker': %w", err)
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for WorkerNodes. Returns the specified
// element and whether it was found
func (a WorkerNodes) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for WorkerNodes
func (a *WorkerNodes) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for WorkerNodes to handle AdditionalProperties
func (a *WorkerNodes) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["count"]; found {
		err = json.Unmarshal(raw, &a.Count)
		if err != nil {
			return fmt.Errorf("error reading 'count': %w", err)
		}
		delete(object, "count")
	}

	if raw, found := object["cpu"]; found {
		err = json.Unmarshal(raw, &a.Cpu)
		if err != nil {
			return fmt.Errorf("error reading 'cpu': %w", err)
		}
		delete(object, "cpu")
	}

	if raw, found := object["memory"]; found {
		err = json.Unmarshal(raw, &a.Memory)
		if err != nil {
			return fmt.Errorf("error reading 'memory': %w", err)
		}
		delete(object, "memory")
	}

	if raw, found := object["storage"]; found {
		err = json.Unmarshal(raw, &a.Storage)
		if err != nil {
			return fmt.Errorf("error reading 'storage': %w", err)
		}
		delete(object, "storage")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for WorkerNodes to handle AdditionalProperties
func (a WorkerNodes) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	object["count"], err = json.Marshal(a.Count)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'count': %w", err)
	}

	object["cpu"], err = json.Marshal(a.Cpu)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'cpu': %w", err)
	}

	object["memory"], err = json.Marshal(a.Memory)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'memory': %w", err)
	}

	object["storage"], err = json.Marshal(a.Storage)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'storage': %w", err)
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}
